# 旧线程池（`threadpool.h`）工作逻辑
**半同步/半反应堆模型中的线程池实现说明**
下面是对仓库中旧线程池实现的结构化说明，便于后续评估是否替换以及如何替换。
## 类型与契约
- 实现形式：模板类 `threadpool<T>`，基于 POSIX `pthread`。
- 任务契约：任务类型 `T` 需要暴露 `void process()` 成员（线程池通过调用 `request->process()` 执行任务）。
## 主要成员
- `int m_thread_number`：固定的线程数量。
- `int m_max_requests`：请求队列最大容量。
- `pthread_t* m_threads`：保存线程句柄的数组。
- `std::list<T*> m_workqueue`：任务队列（存裸指针）。
- `locker m_queuelocker`：互斥锁，用于保护工作队列。
- `sem m_queuestat`：信号量，表示队列中是否有任务（用于唤醒工作线程）。
- `bool m_stop`：停止标志，控制线程循环退出。
## 初始化与线程生命周期
- 构造函数分配 `m_threads`，并以循环创建 `m_thread_number` 个 pthread，线程入口为类静态 `worker`，内部会调用 `run()`。
- 每个线程在创建后被设置为 detached（脱离），因此主线程不会 join 它们。
## 运行时流程（工作线程 `run()`）
1. 工作线程执行 `while (!m_stop)`：
	 - 先调用 `m_queuestat.wait()` 阻塞，直到信号量大于0（表示有任务）。
	 - 获取互斥锁 `m_queuelocker`，检查并从 `m_workqueue` 弹出一个任务指针。
	 - 解锁并调用 `request->process()` 执行任务。
## 任务入队（`append(T* request)`）
- 通过加锁保护队列，检查队列长度是否超过 `m_max_requests`。
- 若未超过则将 `request` push_back 到 `m_workqueue`，然后调用 `m_queuestat.post()` 增加信号量、唤醒等待线程。
## 停止与析构
- 析构函数删除线程数组并将 `m_stop = true`。注意：实现中未显式对所有正在等待的线程调用 `post()` 或其他唤醒手段，因此如果线程仍阻塞在 `m_queuestat.wait()`，它们不会立刻退出，可能导致析构时的竞态或非优雅退出。
## 优点
- 轻量且实现简单，适合资源受限或追求最小依赖的场景。
- 模板化设计，可直接复用到任何实现 `process()` 的任务类型（例如 `http_conn`）。
## 缺点与注意事项
- 线程数固定，不会根据负载自动伸缩，可能导致资源浪费或处理能力不足。
- 使用裸指针传递任务，缺少所有权语义（内存/异常安全依赖于调用方）。
- 析构流程没有可靠唤醒所有阻塞线程的逻辑，存在退出不干净或资源未释放的风险。
- 功能缺乏现代接口（无 future/promise、无任务返回值、无任务取消、无超时处理）。
## 在本项目中的集成（关键点）
- `main.cpp` 中创建线程池：
	- `threadpool<http_conn>* pool = new threadpool<http_conn>;`
- 把连接对象指针加入线程池：
	- 在处理 EPOLLIN 事件且 `users[sockfd].read()` 成功后，调用： `pool->append(users + sockfd);`
	- 线程池会从队列中取出 `http_conn*` 并调用 `http_conn::process()`。因此 `http_conn` 必须实现 `process()`，且其生命周期需由外部（main/EPOLL 逻辑）管理。
## 替换评估要点（简短建议）
- 如果你要替换为现代 C++ 的异步线程池（如 `threadpool-yibu`）：
	- 确保新池能以 `http_conn*` 或等效包装形式接收任务，或修改 `main.cpp` 调用以传递可调用对象（如 lambda 或 std::function）。
	- 处理任务所有权：推荐使用 `std::shared_ptr<http_conn>` 或传值的可调用对象以避免悬空指针。
	- 确保新池析构能优雅停止并唤醒所有工作线程。



# 动态线程池（`threadpool-yibu`）实现说明

下面是对仓库中 `threadpool-yibu.h` / `threadpool-yibu.cpp` 的实现逻辑和要点说明，便于审查和后续改进：

## 合同与接口
- 构造：`ThreadPool(int min = 4, int max = thread::hardware_concurrency())`。
- 提交任务：`void addTask(std::function<void()> f)`，将任务放入内部队列并唤醒工作线程。
- 析构：设置停止标志、通知所有线程，然后 join 管理线程与工作线程。

## 动态伸缩与管理
- 线程池包含一个单独的管理线程 `m_manager`，周期性（2s）检查 `m_idleThreads` 与 `m_curThreads`：
	- 当空闲线程数大于当前线程数的 1/2 且当前线程数超过最小限制时，请求缩减（通过 `m_exitNumber`），并等待 `m_ids` 中被标记退出的线程以 `join()` 并从 `m_workers` 中移除。
	- 当没有空闲线程且当前线程数少于最大时，创建新线程并加入 `m_workers`。

## 工作线程行为
- 工作线程循环等待条件变量，取出任务并执行；当收到退出请求（`m_exitNumber>0`）时，将自身 id 存入 `m_ids` 并返回结束，从而允许管理线程回收该 thread 对象。

## 同步与数据竞争考量
- 任务队列由 `m_queueMutex`+`m_condition` 保护，`m_ids` 由 `m_idsMutex` 保护。
- 注意：对 `m_workers` 的并发访问没有显式 mutex 保护（manager 在遍历并修改 `m_workers`），这存在竞态风险；建议为 `m_workers` 操作添加 mutex 保护，或在更严格的锁策略下统一管理。

## 潜在问题与改进
- `m_exitNumber` 被硬编码为固定值（2），建议改为更灵活策略或配置项。
- `addTask` 没有队列上限或拒绝策略，高负载时可能导致内存增长。建议添加最大队列长度和返回值/抛出机制。
- 任务执行缺少异常保护：若任务抛出异常，可能导致工作线程终止，建议在执行 `task()` 时包裹 try/catch 并记录错误。

## 与旧线程池比较（要点回顾）
- 优点：现代 C++ 实现、支持动态伸缩、析构时 join、任务封装更灵活。
- 缺点：略复杂、需要小心并发边界（如 `m_workers` 访问）、当前实现缺少队列限流与异常安全。

---

追加时间：自动生成。
--- --- IGNORE ---
